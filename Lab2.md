# LAB 2

*by Woooooow~ / start from 2020/10/15 /*

## Solution to the Exercise

### Part 1: Physical Page Management

#### Exercise 1

> **Exercise 1.** In the file kern/pmap.c, you must implement code for the following functions (probably in the order given).
>
> *boot_alloc()*
> *mem_init()* (only up to the call to *check_page_free_list(1)*)
> *page_init()*
> *page_alloc()*
> *page_free()*
>
> *check_page_free_list()* and *check_page_alloc()* test your physical page allocator. You should boot JOS and see whether *check_page_alloc()* reports success. Fix your code so that it passes. You may find it helpful to add your own *assert()*s to verify that your assumptions are correct.

##### boot_alloc()

一开始看这个函数的时候并不知道他要做什么, 跳过这个函数直接看 mem_init() 后发现他只是用来初始化 page table dirctory ( 只在 kernel 启动的时候调用, 多么短暂的一生啊 ).

这时候我意识到这个函数要解决的是个启动时的套娃问题:

> There is a bootstrap problem: all of physical memory must be mapped in order for the allocator to initialize the free list, but creating a page table with those mappings involves allocating page-table pages. -- *xv6 book 2018*

同样 *xv6 book* 给出了解决方案

> xv6 solves this problem by using a separate page allocator during entry, which allocates memory just after the end of the kernel’s data segment. This allocator does not support freeing and is limited by the 4 MB mapping in the entrypgdir, but that is sufficient to allocate the first kernel page table. -- *xv6 book 2018*

这个函数有两个让我非常头疼的问题 ( 虽然这就是他要我们去思考的问题，嘤嘤嘤 )

- How to allowcate chunks of *contiguous physical* memory?
- How to detect how may pysical memory left?

这个函数是在初始化 page directory 的时候被调用, 即 `mem_init()` 中调用, 用于从物理内存中取出 4k Bytes 作为初始的 page table. 在此之前, `mem_init()` 还调用了 `i386_detect_memory()` 函数, 检测环境中有多少可用物理内存空间, 并将结果保存到全局变量 npages 和 npages_basemem 中. 其函数中变量的具体含义如下:

- i386_detect_memory():
  函数功能是检测现在系统中有多少可用的内存空间 ( 物理内存 ), 其中:
  - 0x00000 - 0xA000: basement 可用
  - 0xA0000 - 0x100000: I/O hole 不可用
  - 0x100000 以上为 external memory 可用
  - npages: 记录整个内存的可用的页数
  - npages_basemem: 记录 basement 区域可用页数

再观察要补充完整的函数 `boot_alloc()`, end 是 kernel.ld 直接给的, 如下图 (kernel/kernel.ld:53)
> ![Figure 2-1](assets/img/lab2/lab2_1.png) **Figure 2-1** kernel/kernel.ld:53

标记了可用地址的起始位置. `ROUNDUP` 则是 Round up to the nearest multiple of n. 而 nextfree 则用来标记下一个可用 page 的首地址

从而我们可以通过 `ROUNDUP(nextfree + n, PGSIZE)` 来分配连续 pages, 用 `nextfree - KERNBASE > npages * PGSIZE` 判断是否超出内存, 具体实现如下 ( 其中有部分注释是我写代码的时候加的, ~~不要吐槽我垃圾英语了~~ )

```cpp
static void *
boot_alloc(uint32_t n){
    static char *nextfree; // virtual address of next byte of free memory
    char *result;

    // Initialize nextfree if this is the first time.
    // 'end' is a magic symbol automatically generated by the linker,
    // which points to the end of the kernel's bss segment:
    // the first virtual address that the linker did *not* assign
    // to any kernel code or global variables.
    if (!nextfree) {
        // end means the end of the kernel's bss segment,
        // here in i386 we use the small endian,
        // so the 'end' means highest address of the bss segment.
        extern char end[];
        // nextfree point to the next free page (will the start of that page, at low)
        nextfree = ROUNDUP((char *) end, PGSIZE);
    }

    // Allocate a chunk large enough to hold 'n' bytes, then update
    // nextfree.  Make sure nextfree is kept aligned
    // to a multiple of PGSIZE.
    //
    // LAB 2: Your code here.

    // debug message
    cprintf("boot_alloc: initial kernel page directory started at %x", nextfree);

    result = nextfree;
    if (!n)
        nextfree = ROUNDUP(nextfree + n, PGSIZE);
    if (nextfree - KERNBASE > npages * PGSIZE) {
        panic("boot_alloc: out of memory. Requested %uK, available %uK.\n",
        ((uint32_t)nextfree - (uint32_t)result) / 1024, npages * PGSIZE / 1024);
        result = NULL;
    }

    return result;
}
```

##### page_init()

在 `mem_init()` 函数初始化 page table directory 通过套娃 *Recursively insert PD in itself as a page table, to form a virtual page table at virtual address UVPT.* 将存放 page table directory 的 page 的映射关系存放到了 page table direcctory 中 (这里具体操作我没有完全理解，所以暂时不做解释), 对应的代码如下:

```cpp
//////////////////////////////////////////////////////////////////////
// Recursively insert PD in itself as a page table, to form
// a virtual page table at virtual address UVPT.
// (For now, you don't have understand the greater purpose of the
// following line.)
// I really coundn't understand how it work.

// Permissions: kernel R, user R
kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;
```

然后函数再次调用 `boot_alloc()` 函数, 在之前的用于存放 page table directory 空间的上面取得了一个用于存放 **kernel** page table entry 的 page (这里我理解了好久才意识到, 这些工作只是初始并管理 kernel 空间的内存, 而此时用户空间的内存暂时没有被管理). 而这里被初始化的 page table entry array 顺序对应整个物理内存 ( where kernel located, 具体对应 Figure 2-2 ):

> ![Figure 2-2](assets/img/lab2/lab2_2.png) **Figure 2-2**  From *xv6 book 2018*

对应的实现:

```cpp
pages = (struct PageInfo *) boot_alloc(npages * sizeof(struct PageInfo));
memset(pages, 0, sizeof(struct PageInfo));
```

之后 `mem_init()` 函数调用 `page_init()` 函数进行内存空间页初始化. 而 `page_init()` 函数具体工作则是 1) 将可用的 page 标注, 并以 page_free_list 为 list head 将可用 page 作为 list 连接起来; 2) 将不可用 (或者已经被占用) 的 page 标注.

由题目注释得知, 被占用的 ( 或不可用 ) page 有 page[0]; [IOPHYSMEM, EXTPHYSMEM) 这一段的 I/hO Hole; 以及从 EXTPHYSMEM 开始连续的一段内存 ( 其中包括了 kernel 自身, 以及之前分配的 kernel_pgdir 和 pages ). 从 图 **Figure 2-2** 可以看出 I/O hole 到分配给 PTE 的 page 那块是连续被占用的, 因此可以通过 `((uint32_t) boot_alloc(0) - KERNBASE)` 得到 EXTPHYSMEM 后空闲页的起始位置 ( 还是看图可知, 物理地址 0 被映射到 KERNBASE, 而 `boot_alloc(0)` 则会返回之前分配给 PTE 后下一个可用块的起始虚拟地址, 两者相减除以 PGSIZE 就得到 EXTPHYSMEM 后空闲页的起始位置 ), 具体实现见下:

```cpp
void
page_init(void)
{
    // The example code here marks all physical pages as free.
    // However this is not truly the case.  What memory is free?
    //  1) Mark physical page 0 as in use.
    //     This way we preserve the real-mode IDT and BIOS structures
    //     in case we ever need them.  (Currently we don't, but...)
    //  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)
    //     is free.
    //  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must
    //     never be allocated.
    //  4) Then extended memory [EXTPHYSMEM, ...).
    //     Some of it is in use, some is free. Where is the kernel
    //     in physical memory?  Which pages are already in use for
    //     page tables and other data structures?
    //
    // Change the code to reflect this.
    // NB: DO NOT actually touch the physical memory corresponding to
    // free pages!
    size_t i;
    page_free_list = NULL;

    // calculate the allocatable (or available) memory (page index) in Extended memory
    size_t pgs_avail_extend = ((uint32_t) boot_alloc(0) - KERNBASE) / PGSIZE;

    pages[0].pp_ref = 1;
    pages[0].pp_link = NULL;
    for (i = 1; i < npages_basemem; i++) {
        pages[i].pp_ref = 0;
        pages[i].pp_link = page_free_list;
        page_free_list = &pages[i];
    }
    for (; i < pgs_avail_extend; ++i){
        pages[i].pp_ref = 1;
        pages[i].pp_link = NULL;
    }
    for (; i < npages; ++i){
        pages[i].pp_ref = 0;
        pages[i].pp_link = page_free_list;
        page_free_list = &pages[i];
    }
    return;
}
```

##### page_alloc() AND page_free()

`mem_init()` 调用函数 `check_page_free_list(1)` 将 `page_free_list` list 中的递减的 page 转为递增 ( 如果运行完 `page_init()` 但是 `page_free_list` 存在不应该有的东西, 就会导致疯狂重启. 我试过了, 体验良好, 搞了 2h 才知道是这个函数在逼迫 jos 重启 ), 然后调用 `check_page_alloc()` 函数, 而这个函数会调用我们的 `page_alloc()` 和 `page_free()` 函数, 如果测试成功就返回 ‘ *check_page_alloc() succeeded!* ’

其中 `page_free()` 函数超级好写, 具体如下:

```cpp
void
page_free(struct PageInfo *pp)
{
    // Fill this function in
    // Hint: You may want to panic if pp->pp_ref is nonzero or
    // pp->pp_link is not NULL.
    if (pp->pp_ref != 0 || pp->pp_link != NULL){
        panic("page_free: pp_ref is nonzero or pp_link is not NULL.\n\
    pp: %08x { pp_ref: %d, pp_link: %08x }", pp, pp->pp_ref, pp->pp_link);
        return;
    }

    pp->pp_link = page_free_list;
    page_free_list = pp;
}
```

`page_alloc()` 函数要注意的就是不要*脑残* ( 指我自己 ) 给 pp_ref 加上 1 ( 不应该在这里实现 ), 具体实现如下:

```cpp
struct PageInfo *
page_alloc(int alloc_flags)
{
    // out of free memory
    if (!page_free_list)
        return NULL;

    struct PageInfo *result = page_free_list;
    page_free_list = result->pp_link;
    result->pp_link = NULL;

    // If (alloc_flags & ALLOC_ZERO), fills the entire 
    // returned physical page with '\0' bytes.
    if(alloc_flags & ALLOC_ZERO)
        memset(page2kva(result), 0, PGSIZE);

    return result;
}
```

##### RESULT

> ![Figure 2-3](assets/img/lab2/lab2_3.png) **Figure 2-3**

### Part 2: Virtual Memory

#### Exercise 2

> **Exercise 2.** Look at chapters 5 and 6 of the [Intel 80386 Reference Manual](https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm), if you haven't done so already. Read the sections about page translation and page-based protection closely (5.2 and 6.4). We recommend that you also skim the sections about segmentation; while JOS uses the paging hardware for virtual memory and protection, segment translation and segment-based protection cannot be disabled on the x86, so you will need a basic understanding of it.

没说要写代码就是没有事, 嗯 ( 以后有时间补上? )

#### Exercise 3

> **Exercise 3.** While GDB can only access QEMU's memory by virtual address, it's often useful to be able to inspect physical memory while setting up virtual memory. Review the QEMU [monitor commands](https://pdos.csail.mit.edu/6.828/2018/labguide.html#qemu) from the lab tools guide, especially the xp command, which lets you inspect physical memory. To access the QEMU monitor, press `Ctrl-a c` in the terminal (the same binding returns to the serial console).
>
> Use the `xp` command in the QEMU monitor and the `x` command in GDB to inspect memory at corresponding physical and virtual addresses and make sure you see the same data.
>
> Our patched version of QEMU provides an `info pg` command that may also prove useful: it shows a compact but detailed representation of the current page tables, including all mapped memory ranges, permissions, and flags. Stock QEMU also provides an `info mem` command that shows an overview of which ranges of virtual addresses are mapped and with what permissions.

#### Question 1

> Assuming that the following JOS kernel code is correct, what type should variable `x` have, `uintptr_t` or `physaddr_t`?
> ```cpp
> mystery_t x;  
> char* value = return_a_pointer();  
> *value = 10;  
> x = (mystery_t) value;  
> ```

## 有趣的发现

1. 第一次注意到原来 c 也有类似于 python 一样的文档字符串 (用来解释函数在干啥的，即函数前面那一串标准的解释注释)

## Question

1. 没看懂 /kernel/pmap.c/check_page_free_list() 函数, 这个真的太绝望了.